## Add

```swift
// Default rounding: toNearestOrEven
func adding(_ other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus) -> Self
func adding(_ other: Self, rounding: DecimalFloatingPointRoundingRule) -> Self
func adding(_ other: Self, status: inout DecimalStatus) -> Self
func adding(_ other: Self) -> Self

mutating func add(_ other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus)
mutating func add(_ other: Self, rounding: DecimalFloatingPointRoundingRule)
mutating func add(_ other: Self, status: inout DecimalStatus)
mutating func add(_ other: Self)

static func + (lhs: Self, rhs: Self) -> Self
static func += (lhs: inout Self, rhs: Self)
```

The most interesting edge cases for add/sub are:

1. special case when adding different signs (or subtracting same sign)

    ```swift
    // Decimal32 precision is 7.
    let lhs = Decimal32("1000000E8")!
    let rhs = Decimal32("5000001")!
    let result = lhs.subtracting(rhs, rounding: .toNearestOrAwayFromZero)
    print(result) // 9999999E+7
    ```

    Look closely at the numbers, this should NOT make sense. `rhs` is way smaller than `lhs`, it should round it back to `lhs` (we are well within `lhs.ulp/2 = 1E+8/2`), and yet apparently it didn't. The numbers that I used do contain a hint as to what is going on.

2. sign of exact `0`

    ```swift
    let lhs = Decimal32("123")!
    let rhs = Decimal32("123")!
    let result = lhs.subtracting(rhs, rounding: .down)
    print(result) // -0E+0
    ```

@mgriebling
Don't worry, your code handles them correctly giving:
1. `9.999999e+13`
2. `-0`

This is actually impressive.

## Sub

```swift
// Default rounding: toNearestOrEven
func subtracting(_ other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus) -> Self
func subtracting(_ other: Self, rounding: DecimalFloatingPointRoundingRule) -> Self
func subtracting(_ other: Self, status: inout DecimalStatus) -> Self
func subtracting(_ other: Self) -> Self

mutating func subtract(_ other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus)
mutating func subtract(_ other: Self, rounding: DecimalFloatingPointRoundingRule)
mutating func subtract(_ other: Self, status: inout DecimalStatus)
mutating func subtract(_ other: Self)

static func - (lhs: Self, rhs: Self) -> Self
static func -= (lhs: inout Self, rhs: Self)
```

## Mul

```swift
// Default rounding: toNearestOrEven
func multiplied(by other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus) -> Self
func multiplied(by other: Self, rounding: DecimalFloatingPointRoundingRule) -> Self
func multiplied(by other: Self, status: inout DecimalStatus) -> Self
func multiplied(by other: Self) -> Self

mutating func multiply(by other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus)
mutating func multiply(by other: Self, rounding: DecimalFloatingPointRoundingRule)
mutating func multiply(by other: Self, status: inout DecimalStatus)
mutating func multiply(by other: Self)

static func * (lhs: Self, rhs: Self) -> Self
static func *= (lhs: inout Self, rhs: Self)
```

## Div

```swift
// Default rounding: toNearestOrEven
func divided(by other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus) -> Self
func divided(by other: Self, rounding: DecimalFloatingPointRoundingRule) -> Self
func divided(by other: Self, status: inout DecimalStatus) -> Self
func divided(by other: Self) -> Self

mutating func divide(by other: Self, rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus)
mutating func divide(by other: Self, rounding: DecimalFloatingPointRoundingRule)
mutating func divide(by other: Self, status: inout DecimalStatus)
mutating func divide(by other: Self)

static func / (lhs: Self, rhs: Self) -> Self
static func /= (lhs: inout Self, rhs: Self)
```

- `0 / finite = 0`
- `0 / 0 = nan + invalid operation`
- `finite / 0 = inf + divisionByZero`

There is an interesting part of the algorithm where you have to count trailing 0s of the result and possibly increase the exponent. Intel uses tables, but I went with manually unrolled binary search. We always divide by a power of 10 and with unrolling we can make them compile time constants, so the code generated by the compiler does not contain any divisions. At least that is what compiler explorer (godbolt.org) says.

`UInt64` can have at max 20 trailing zeros, so we have `⌈log2(20)⌉ = ⌈4.32…⌉ = 5` divisions. For `UInt128` it is `6`, because apparently this is how binary search works.

IDK, maybe tables are better.

## Remainder

```swift
func remainder(dividingBy other: Self, status: inout DecimalStatus) -> Self
func remainder(dividingBy other: Self) -> Self

mutating func formRemainder(dividingBy other: Self, status: inout DecimalStatus)
mutating func formRemainder(dividingBy other: Self)

func truncatingRemainder(dividingBy other: Self, status: inout DecimalStatus) -> Self
func truncatingRemainder(dividingBy other: Self) -> Self

mutating func formTruncatingRemainder(dividingBy other: Self, status: inout DecimalStatus)
mutating func formTruncatingRemainder(dividingBy other: Self)
```

No rounding and no operators!

Intel does not have `truncatingRemainder`, so we have to implement it ourself.

@mgriebling implementation:

```swift
// mgriebling code
// https://github.com/mgriebling/DecimalNumbers/tree/main

public struct Decimal32 : Codable, Hashable {
  public mutating func formTruncatingRemainder(dividingBy other: Self) {
    let q = (self/other).rounded(.towardZero)
    self -= q * other
  }
}
```

I have not checked this, but my intuition says that it may not be correct.

In oh-my-decimal:

```swift
extension DecimalMixin {

  internal func _remainder(dividingBy other: Self, status: inout DecimalStatus) -> Self {
    return self._remainder(dividingBy: other, status: &status, isNear: true)
  }

  internal func _truncatingRemainder(dividingBy other: Self, status: inout DecimalStatus) -> Self {
    return self._remainder(dividingBy: other, status: &status, isNear: false)
  }

  private func _remainder(
    dividingBy other: Self,
    status: inout DecimalStatus,
    isNear: Bool
  ) -> Self {
    (…)

    if isNear {
      Self._remRoundQuotientAwayFromZeroIfNeeded(
        sign: &sign,
        quotient: quotient,
        remainder: &remainder,
        rhsSignificand: rhsSignificand
      )
    }
  }
}
```

So both of the methods call the same function with `isNear: Bool` flag. This flag is checked in 2 places to potentially call `Self._remRoundQuotientAwayFromZeroIfNeeded`. Obviously at no point we actually calculate the proper `quotient`, there is no need for it. See the github repository for more details.

## Square root

```swift
// Default rounding: toNearestOrEven
func squareRoot(rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus) -> Self
func squareRoot(rounding: DecimalFloatingPointRoundingRule) -> Self
func squareRoot(status: inout DecimalStatus) -> Self
func squareRoot() -> Self

mutating func formSquareRoot(rounding: DecimalFloatingPointRoundingRule, status: inout DecimalStatus)
mutating func formSquareRoot(rounding: DecimalFloatingPointRoundingRule)
mutating func formSquareRoot(status: inout DecimalStatus)
mutating func formSquareRoot()
```

How about adding `Int.squareRootFloor` to Swift Numerics? It is [important that this is `floor`](https://en.wikipedia.org/wiki/Integer_square_root). I'm sure that every programmer at some point had to write it.

Just last saturday (!) I was invited to collaborate (with commit access) on a Python repo regarding [Trouble-with-python3.12-function-sqrt](https://github.com/Baroudeme/Trouble-with-python3.12-function-sqrt/issues/1). Totally unknown person just inviting you to a repo with this exact problem! (My best guess is that this is some kind of recrutation tactic - programming interview 2.0. Please don't do this.)

In oh-my-decimal we have to implement it manually:
- `UInt32` -> from `Double`
- `UInt64` -> from `Double ±1` for correction
- `UInt128` -> Newton + `log2` estimation
- `UInt256` (yes, we have this type, don't ask) -> Newton + `log2` estimation (same code as `UInt128`)

## FMA

```swift
// Default rounding: toNearestOrEven
func addingProduct(
  _ lhs: Self,
  _ rhs: Self,
  rounding: DecimalFloatingPointRoundingRule,
  status: inout DecimalStatus
) -> Self
func addingProduct(_ lhs: Self, _ rhs: Self, rounding: DecimalFloatingPointRoundingRule) -> Self
func addingProduct(_ lhs: Self, _ rhs: Self, status: inout DecimalStatus) -> Self
func addingProduct(_ lhs: Self, _ rhs: Self) -> Self

mutating func addProduct(
  _ lhs: Self,
  _ rhs: Self,
  rounding: DecimalFloatingPointRoundingRule,
  status: inout DecimalStatus
)
mutating func addProduct(_ lhs: Self, _ rhs: Self, rounding: DecimalFloatingPointRoundingRule)
mutating func addProduct(_ lhs: Self, _ rhs: Self, status: inout DecimalStatus)
mutating func addProduct(_ lhs: Self, _ rhs: Self)
```

I'm not the biggest fan of how FMA works in Swift, I would rather see a `static` method. The 1st instinct is to look for `fusedMultiplyAdd` and that gives nothing in code completion.

Anyway… it is FMA, so I will not even list all of the possible edge cases. I can vouch for [Hossam A. H. Fahmy test suite](http://eece.cu.edu.eg/~hfahmy/arith_debug/). Those tests are not exhaustive, but they are waaaay better than anything that I could ever create.

Be prepared that writing `fma` will also force re-write of `add`. In oh-my-decimal from certain point almost everything is shared - this makes `add` more complicated than it needs to be.

\<rant\>

Implementing FMA is such a massive waste of time. Oh-my-decimal code is so complicated that I'm sure that there is a bug somewhere. The best thing is that this method is quite useless on `Decimal`, because most of the time you want a separate `mul` and `add`. I may be wrong but `Foundation.Decimal` does not even have it.

But standard requires it, and so does `FloatingPoint` protocol. So, good luck to whoever is going to implement it. I'm just happy that this is not me. I already suffered enough.

\</rant\>
